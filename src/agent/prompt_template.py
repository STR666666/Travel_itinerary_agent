from typing import Union, List
import re
from langchain.agents import Tool, AgentOutputParser
from langchain.callbacks.base import BaseCallbackHandler
from langchain.prompts import BaseChatPromptTemplate
from langchain.schema import AgentAction, AgentFinish, HumanMessage
from src.utils import global_value


class StreamPlan(BaseCallbackHandler):
    """ Callback handler to update travel plans with new tokens generated by LLM. """
    
    def __init__(self, agent_id: int):
        self.agent_id = agent_id

    def on_llm_new_token(self, token: str, **kwargs) -> None:
        """Callback function to add new token to travel plans."""
        agent = global_value.get_dict_value('agents', self.agent_id)
        agent.UI_info.travel_plans[-1] += token


class GeneralPromptTemplate(BaseChatPromptTemplate):
    """ Template for constructing general prompts for LLM. """
    
    template: str

    def format_messages(self, **kwargs) -> List[HumanMessage]:
        """Formats messages using the defined template."""
        formatted = self.template.format(**kwargs)
        return [HumanMessage(content=formatted)]


class T5PromptTemplate(BaseChatPromptTemplate):
    """ Template for constructing T5 style prompts for LLM. """

    template: str
    tools: List[Tool]

    def format_messages(self, **kwargs) -> List[HumanMessage]:
        """Formats messages using the T5 template and available tools."""
        intermediate_steps = kwargs.pop("intermediate_steps")
        thoughts = ""

        for action, observation in intermediate_steps:
            thoughts += action.log
            thoughts += (
                f"\nTool output: {observation}\nTool reflect:"
                "1. Do I need an external tool at the current step? If I need a tool, which tool should I call at the current step?\n"
                "2. Which other tools does this tool depend on?\n"
                "3. Remember that I can't generate Final Answer until I have called all possible tools to solve the user's problem perfectly.\n"
                "Thought:"
            )

        kwargs["agent_scratchpad"] = thoughts
        kwargs["tools"] = "\n\n".join([f"{tool.name}: {tool.description}" for tool in self.tools])
        kwargs["tool_names"] = ", ".join([tool.name for tool in self.tools])
        formatted = self.template.format(**kwargs)

        return [HumanMessage(content=formatted)]


class ReActPromptTemplate(BaseChatPromptTemplate):
    """ Template for constructing ReAct style prompts for LLM. """

    template: str
    tools: List[Tool]

    def format_messages(self, **kwargs) -> List[HumanMessage]:
        """Formats messages using the ReAct template and available tools."""
        intermediate_steps = kwargs.pop("intermediate_steps")
        thoughts = ""

        for action, observation in intermediate_steps:
            thoughts += action.log
            thoughts += f"\nObservation: {observation}\nThought: "

        kwargs["agent_scratchpad"] = thoughts
        kwargs["tools"] = "\n\n".join([f"{tool.name}: {tool.description}" for tool in self.tools])
        kwargs["tool_names"] = ", ".join([tool.name for tool in self.tools])
        formatted = self.template.format(**kwargs)

        return [HumanMessage(content=formatted)]


class T5OutputParser(AgentOutputParser):
    """Parser for extracting Tool/Tool input from LLM generated content."""

    def parse(self, llm_output: str) -> Union[AgentAction, AgentFinish]:
        """Parses the output from LLM and extracts the tool and tool input."""
        if "Final Answer:" in llm_output:
            parse_ls = llm_output.split("Final Answer:")
            return AgentFinish(
                return_values={"output": (parse_ls[0] + parse_ls[1]).strip()},
                log=llm_output,
            )

        regex = r"Tool\s*\d*\s*:(.*?)\nTool\s*\d*\s*[iI]nput\s*\d*\s*:[\s]*(.*)"
        match = re.search(regex, llm_output, re.DOTALL)

        if not match:
            return AgentAction(tool="None", tool_input="None", log=llm_output)

        tool = match.group(1).strip()
        tool_input = match.group(2).strip(" ").strip('"')

        return AgentAction(tool=tool, tool_input=tool_input, log=llm_output)


class ReActOutputParser(AgentOutputParser):
    """ Parser for extracting Action/Action input from LLM generated content. """

    def parse(self, llm_output: str) -> Union[AgentAction, AgentFinish]:
        """Parses the output from LLM and extracts the action and action input."""
        if "Final Answer:" in llm_output:
            parse_ls = llm_output.split("Final Answer:")
            return AgentFinish(
                return_values={"output": (parse_ls[0] + parse_ls[1]).strip()},
                log=llm_output,
            )

        regex = r"Action\s*\d*\s*:(.*?)\nAction\s*\d*\s*[iI]nput\s*\d*\s*:[\s]*(.*)"
        match = re.search(regex, llm_output, re.DOTALL)

        if not match:
            return AgentAction(tool="None", tool_input="None", log=llm_output)

        action = match.group(1).strip()
        action_input = match.group(2).strip(" ").strip('"')

        return AgentAction(tool=action, tool_input=action_input, log=llm_output)